{
  mkEpicsPackage,
  stdenv,
  lib,
  epnixLib,
  buildPackages,
  fetchFromGitHub,
  version,
  hash,
}:
let
  older = lib.versionOlder version;

  generateConf = (epnixLib.formats.make { }).generate;

  # "build" as in Nix terminology (the build machine)
  build_arch = epnixLib.toEpicsArch stdenv.buildPlatform;
  # "host" as in Nix terminology (the machine which will run the generated code)
  host_arch = epnixLib.toEpicsArch stdenv.hostPlatform;
in
mkEpicsPackage {
  pname = "epics-base";
  inherit version;
  varname = "EPICS_BASE";

  isEpicsBase = true;

  src = fetchFromGitHub {
    owner = "epics-base";
    repo = "epics-base";
    tag = "R${version}";
    inherit hash;
    fetchSubmodules = true;
  };

  patches = lib.optionals (older "7.0.5") [
    # Support "undefine MYVAR" in convertRelease.pl
    # Fixed by commit 79d7ac931502e1c25b247a43b7c4454353ac13a6
    ./handle-make-undefine-variable.patch
  ];

  # Configuration file for how to compile for the build machine.
  build_config_site =
    let
      inherit (buildPackages.stdenv) cc;
    in
    generateConf (
      {
        CC = "${cc.targetPrefix}cc";
        CCC = "${cc.targetPrefix}c++";
        CXX = "${cc.targetPrefix}c++";

        AR = "${cc.bintools.targetPrefix}ar";
        LD = "${cc.bintools.targetPrefix}ld";
        RANLIB = "${cc.bintools.targetPrefix}ranlib";

        ARFLAGS = "rc";
      }
      // lib.optionalAttrs cc.isClang {
        GNU = "NO";
        CMPLR_CLASS = "clang";
      }
    );

  # Configuration file for how to compile for the "host" machine,
  # the machine that will run the final code
  # (what EPICS calls the "target" machine).
  host_config_site =
    let
      inherit (stdenv) cc;
    in
    generateConf (
      {
        CC = "${cc.targetPrefix}cc";

        CCC = if stdenv.cc.isClang then "${cc.targetPrefix}clang++" else "${cc.targetPrefix}c++";
        CXX = if stdenv.cc.isClang then "${cc.targetPrefix}clang++" else "${cc.targetPrefix}c++";

        AR = "${cc.bintools.targetPrefix}ar";
        LD = "${cc.bintools.targetPrefix}ld";
        RANLIB = "${cc.bintools.targetPrefix}ranlib";

        ARFLAGS = "rc";

        COMMANDLINE_LIBRARY = "READLINE_NCURSES";
      }
      // lib.optionalAttrs cc.isClang {
        GNU = "NO";
        CMPLR_CLASS = "clang";
      }
    );

  postConfigure = ''
    echo "$build_config_site" > configure/os/CONFIG_SITE.${build_arch}.${build_arch}
    echo "$host_config_site" > configure/os/CONFIG_SITE.${build_arch}.${host_arch}

    echo "=============================="
    echo "CONFIG_SITE.${build_arch}.${build_arch}"
    echo "------------------------------"
    cat "configure/os/CONFIG_SITE.${build_arch}.${build_arch}"
    echo "=============================="
    echo "CONFIG_SITE.${build_arch}.${host_arch}"
    echo "------------------------------"
    cat "configure/os/CONFIG_SITE.${build_arch}.${host_arch}"
    echo "------------------------------"
  '';

  # TODO: removing build platform Perl library actually removes every Perl
  # library since it's the only one...
  preFixup =
    ''
      # Remove lines that start with `#` for the TOOLCHAIN files.
      #
      # This file is generated by `gcc -E`, and outputs header dependencies in the
      # "comments". Unfortunately, a glibc header is part of them, which means Nix
      # would pull `glibc.dev` as a runtime dependency, which would add ~10MB to
      # the closure.
      #
      # The file is sourced by Make, so comments should have no effect
      for file in $out/cfg/TOOLCHAIN.*; do
        sed -i '/^#/d' "$file"
      done
    ''
    + (lib.optionalString (stdenv.buildPlatform != stdenv.hostPlatform) ''
      # Remove the build platform pkg-config file, since we are stripping the
      # build platform outputs from the result
      # TODO: the architecture may be differently named in certain cases (e.g. windows)
      #
      # Also remove the build platform "native" perl library
      rm -rf \
        $out/lib/pkgconfig/epics-base-${stdenv.buildPlatform.linuxArch}.pc \
        $out/lib/perl/*/${stdenv.buildPlatform.system}*
    '');

  # TODO: Some tests fail
  doCheck = false;

  meta = {
    description = "The Experimental Physics and Industrial Control System";
    homepage = "https://epics-controls.org/";
    license = epnixLib.licenses.epics;
    maintainers = with epnixLib.maintainers; [ minijackson ];
  };
}
